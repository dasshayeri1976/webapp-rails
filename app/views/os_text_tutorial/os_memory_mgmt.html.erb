<!DOCTYPE html>
<html>
<head>
<title>Operating Systems</title>
<%= stylesheet_link_tag 'ds2.scss' %>
 <center><h1>LearnOnline</h1></center>
     <center><h7>-an online study point</h7></center>
      <hr/>
</head>
<body>
<div style="background-color:#FFFFE0;height:400px;width:280px;float:left;">
<meta name="description" content="Operating System Tutorial for Beginners:A beginner's tutorial containing complete knowledge about an operating system starting from its Definition, Functions, Conceptual View, Program Execution, Program Execution, Communication, Error Handling, User Account Management, Multitasking, Real Time System, Process, Program, Memory Management, and Security, Overview, Types, Services, Properties, Processes, Process Scheduling, Scheduling Algorithms, Multithreading, Virtual Memory, I/O Hardware, I/O Software, File System, Linux.Created by Shayeri Das,M.sc 4th sem,BHU-2015-17,4th semester project" />
<meta name="Keywords" content="Operating System, Tutorials, Learning, Beginners, Basics, Definition, Functions, Conceptual View, Program Execution, Program Execution, Communication, Error Handling, User Account Management, Multitasking, Real Time System, Process, Program, Memory Management, Security, Overview, Types, Services, Properties, Processes, Process Scheduling, Scheduling Algorithms, Multithreading, Virtual Memory, I/O Hardware, I/O Software, File System, Linux." />
<ul>
<class>Operating System Contents:</class>
<li><%= link_to 'Home', os_home_path%></li>
<li><%= link_to 'Overview', os_overview_path%></li>
<li><%= link_to 'Types', os_types_path%></li>
<li><%= link_to 'Services', os_services_path%></li>
<li><%= link_to 'Properties', os_properties_path%></li>
<li><%= link_to 'Processes', os_processes_path%></li>
<li><%= link_to 'Process Scheduling', os_process_scheduling_path%></li>
<li><%= link_to 'Scheduling Algorithms', os_process_scheduling_algorithms_path%></li> 
<li><%= link_to 'Multi-threading', os_multi_threading_path%></li>
<li><%= link_to 'Memory Management', os_memory_mgmt_path%></li>
<li><%= link_to 'Virtual Memory', os_virtual_memory_path%></li>
<li><%= link_to 'I/O Hardware', os_io_hw_path%></li>
<li><%= link_to 'I/O Software', os_io_sw_path%></li>
<li><%= link_to 'File System', os_files_path%></li>
<li><%= link_to 'Security', os_security_path%></li>
<li><%= link_to 'Linux', os_linux_path%></li>
</ul>
</div>
<div style="height:1090px;width:1000px;float:right;">
<td style="text-align: right; vertical-align: top">
<div class="front-menu">
<table cellpadding="10">
<tr><td style="text-align: left">
<h4>Operating Systems Memory Management</h4>
<p>Memory management is the functionality of an operating system which handles or
manages primary memory and moves processes back and forth between main memory
and disk during execution. Memory management keeps track of each and every memory
location, regardless of either it is allocated to some process or it is free. It checks how much memory is to be allocated to processes. It decides which process will get memory at what time. It tracks whenever some memory gets freed or unallocated and correspondingly it updates the status.</p>
<p>This tutorial will teach you basic concepts related to Memory Management.</p>
<h7>Process Address Space</h7>
<p>The process address space is the set of logical addresses that a process references in its code. For example, when 32-bit addressing is in use, addresses can range from 0 to 0x7fffffff; that is, 2^31 possible numbers, for a total theoretical size of 2 gigabytes.</p>
<p>The operating system takes care of mapping the logical addresses to physical addresses at the time of memory allocation to the program. There are three types of addresses used in a program before and after memory is allocated &minus;</p>
<div align="center"><table border="1" cellpadding="5" cellspacing="5" style="text-align:center;" class="table table-bordered">
<tr>
<th style="width:5%; text-align:center;">S.N.</th>
<th style="width:85%; text-align:center">Memory Addresses &amp; Description</th>
</tr>
<tr>
<td>1</td>
<td>
<p><b>Symbolic addresses</b></p>
<p>The addresses used in a source code. The variable names, constants, and instruction labels are the basic elements of the symbolic address space.</p>
</td>
</tr>
<tr>
<td>2</td>
<td>
<p><b>Relative addresses</b></p>
<p>At the time of compilation, a compiler converts symbolic addresses into relative
addresses.</p>
</td>
</tr>
<tr>
<td>3</td>
<td><p><b>Physical addresses</b></p>
<p>The loader generates these addresses at the time when a program is loaded into main memory.</p>
</td>
</tr>
</table>
</div>
<p>Virtual and physical addresses are the same in compile-time and load-time address-binding schemes. Virtual and physical addresses differ in execution-time address-binding scheme.</p>
<p>The set of all logical addresses generated by a program is referred to as a <b>logical address space</b>. The set of all physical addresses corresponding to these logical addresses is referred to as a <b>physical address space.</b></p>
<p>The runtime mapping from virtual to physical address is done by the memory management unit (MMU) which is a hardware device. MMU uses following mechanism to convert virtual address to physical address.</p>
<ul class="list">
<li><p>The value in the base register is added to every address generated by a user process, which is treated as offset at the time it is sent to memory. For example, if the base register value is 10000, then an attempt by the user to use address location 100 will be dynamically reallocated to location 10100.</p></li>
<li><p>The user program deals with virtual addresses; it never sees the real physical addresses.</p></li>
</ul>
<h7>Static vs Dynamic Loading</h7>
<p>The choice between Static or Dynamic Loading is to be made at the time of computer program being developed. If you have to load your program statically, then at the time of compilation, the complete programs will be compiled and linked without leaving any external program or module dependency. The linker combines the object program with other necessary object modules into an absolute program, which also includes logical addresses.</p>
<p>If you are writing a Dynamically loaded program, then your compiler will compile the program and for all the modules which you want to include dynamically, only references will be provided and rest of the work will be done at the time of execution.</p>
<p>At the time of loading, with <b>static loading</b>, the absolute program (and data) is loaded into memory in order for execution to start.</p>
<p>If you are using <b>dynamic loading</b>, dynamic routines of the library are stored on a disk in relocatable form and are loaded into memory only when they are needed by the program.</p>
<h7>Static vs Dynamic Linking</h7>
<p>As explained above, when static linking is used, the linker combines all other modules needed by a program into a single executable program to avoid any runtime dependency.</p>
<p>When dynamic linking is used, it is not required to link the actual module or library with the program, rather a reference to the dynamic module is provided at the time of compilation and linking. Dynamic Link Libraries (DLL) in Windows and Shared Objects in Unix are good examples of dynamic libraries.</p>
<h7>Swapping</h7>
<p>Swapping is a mechanism in which a process can be swapped temporarily out of main memory (or move) to secondary storage (disk) and make that memory available to other processes. At some later time, the system swaps back the process from the secondary storage to main memory.</p>
<p>Though performance is usually affected by swapping process but it helps in running multiple and big processes in parallel and that's the reason <b>Swapping is also known as a technique for memory compaction</b>.</p>
<div align="center"><%= image_tag("process_swapping.jpg", :alt => "Swapping") %></div>
<p>The total time taken by swapping process includes the time it takes to move the entire process to a secondary disk and then to copy the process back to memory, as well as the time the process takes to regain main memory.</p>
<p>Let us assume that the user process is of size 2048KB and on a standard hard disk where swapping will take place has a data transfer rate around 1 MB per second. The actual transfer of the 1000K process to or from memory will take</p>
<pre class="result notranslate">
2048KB / 1024KB per second
= 2 seconds
= 2000 milliseconds
</pre>
<p>Now considering in and out time, it will take complete 4000 milliseconds plus other overhead where the process competes to regain main memory.</p>
<h7>Memory Allocation</h7>
<p>Main memory usually has two partitions &minus;</p>
<ul class="list">
<li><p><b>Low Memory</b> &minus; Operating system resides in this memory.</p></li>
<li><p><b>High Memory</b> &minus; User processes are held in high memory.</p></li>
</ul>
<p>Operating system uses the following memory allocation mechanism.</p>
<div align="center"><table border="1" cellpadding="5" cellspacing="5" style="text-align:center;" class="table table-bordered">
<tr>
<th style="width:5%; text-align:center;">S.N.</th>
<th style="width:90%; text-align:center;">Memory Allocation &amp; Description</th>
</tr>
<tr>
<td>1</td>
<td><p><b>Single-partition allocation</b></p>
<p>In this type of allocation, relocation-register scheme is used to protect user processes from each other, and from changing operating-system code and data. Relocation register contains value of smallest physical address whereas limit register contains range of logical addresses. Each logical address must be less than the limit register.</p></td>
</tr>
<tr>
<td>2</td>
<td><p><b>Multiple-partition allocation</b></p>
<p>In this type of allocation, main memory is divided into a number of fixed-sized
partitions where each partition should contain only one process. When a partition
is free, a process is selected from the input queue and is loaded into the free
partition. When the process terminates, the partition becomes available for
another process.</p></td>
</tr>
</table>
</div>
<h7>Fragmentation</h7>
<p>As processes are loaded and removed from memory, the free memory space is broken into little pieces. It happens after sometimes that processes cannot be allocated to memory blocks considering their small size and memory blocks remains unused. This problem is known as Fragmentation.</p>
<p>Fragmentation is of two types &minus;</p>
<div align="center"><table border="1" cellpadding="5" cellspacing="5" style="text-align:center;" class="table table-bordered">
<tr>
<th style="width:5%; text-align:center;">S.N.</th>
<th style="width:90%; text-align:center;">Fragmentation &amp; Description</th>
</tr>
<tr>
<td>1</td>
<td><p><b>External fragmentation</b></p>
<p>Total memory space is enough to satisfy a request or to reside a process in it, but it is not contiguous, so it cannot be used.</p></td>
</tr>
<tr>
<td>2</td>
<td><p><b>Internal fragmentation</b></p>
<p>Memory block assigned to process is bigger. Some portion of memory is left unused, as it cannot be used by another process.</p></td>
</tr>
</table>
<p>The following diagram shows how fragmentation can cause waste of memory and a compaction technique can be used to create more free memory out of fragmented memory &minus;</p>
<div align="center"><%= image_tag("memory_fragmentation.jpg", :alt => "Fragmentation") %></div>
<p>External fragmentation can be reduced by compaction or shuffle memory contents to place all free memory together in one large block. To make compaction feasible, relocation should be dynamic.</p>
<p>The internal fragmentation can be reduced by effectively assigning the smallest partition but large enough for the process.</p>
<h7>Paging</h7>
<p>A computer can address more memory than the amount physically installed on the system. This extra memory is actually called virtual memory and it is a section of a hard that's set up to emulate the computer's RAM. Paging technique plays an important role in implementing virtual memory.</p>
<p>Paging is a memory management technique in which process address space is broken into blocks of the same size called <b>pages</b> (size is power of 2, between 512 bytes and 8192 bytes). The size of the process is measured in the number of pages.</p>
<p>Similarly, main memory is divided into small fixed-sized blocks of (physical) memory called <b>frames</b> and the size of a frame is kept the same as that of a page to have optimum utilization of the main memory and to avoid external fragmentation.</p>
<div align="center"><%= image_tag("paging.jpg", :alt => "Paging") %></div>
<h7>Address Translation</h7>
<p>Page address is called <b>logical address</b> and represented by <b>page number</b> and the <b>offset</b>.</p>
<pre class="result notranslate">
Logical Address = Page number + page offset
</pre> 
<p>Frame address is called <b>physical address</b> and represented by a <b>frame number</b> and the <b>offset</b>.</p>
<pre class="result notranslate">
Physical Address = Frame number + page offset
</pre>
<p>A data structure called <b>page map table</b> is used to keep track of the relation between a page of a process to a frame in physical memory.</p>
<div align="center"><%= image_tag("page_map_table.jpg", :alt => "Page Map Table") %></div>
<p>When the system allocates a frame to any page, it translates this logical address into a physical address and create entry into the page table to be used throughout execution of the program.</p>
<p>When a process is to be executed, its corresponding pages are loaded into any available memory frames. Suppose you have a program of 8Kb but your memory can accommodate only 5Kb at a given point in time, then the paging concept will come into picture. When a computer runs out of RAM, the operating system (OS) will move idle or unwanted pages of memory to secondary memory to free up RAM for other processes and brings them back when needed by the program.</p>
<p>This process continues during the whole execution of the program where the OS keeps removing idle pages from the main memory and write them onto the secondary memory and bring them back when required by the program.</p>
<h7>Advantages and Disadvantages of Paging</h7>
<p>Here is a list of advantages and disadvantages of paging &minus;</p>
<ul class="list">
<li><p>Paging reduces external fragmentation, but still suffer from internal fragmentation.</p></li>
<li><p>Paging is simple to implement and assumed as an efficient memory management technique.</p></li>
<li><p>Due to equal size of the pages and frames, swapping becomes very easy.</p></li>
<li><p>Page table requires extra memory space, so may not be good for a system having small RAM.</p></li>
</ul>
<h7>Segmentation</h7>
<p>Segmentation is a memory management technique in which each job is divided into several segments of different sizes, one for each module that contains pieces that perform related functions. Each segment is actually a different logical address space of the program.</p>
<p>When a process is to be executed, its corresponding segmentation are loaded into non-contiguous memory though every segment is loaded into a contiguous block of available memory.</p>
<p>Segmentation memory management works very similar to paging but here segments are of variable-length where as in paging pages are of fixed size.</p>
<p>A program segment contains the program's main function, utility functions, data structures, and so on. The operating system maintains a <b>segment map table</b> for every process and a list of free memory blocks along with segment numbers, their size and corresponding memory locations in main memory. For each segment, the table stores the starting address of the segment and the length of the segment. A reference to a memory location includes a value that identifies a segment and an offset.</p>
<div align="center"><%= image_tag("segment_map_table.jpg", :alt => "Segment Map Table") %></div>
<hr />
</body>
</html>
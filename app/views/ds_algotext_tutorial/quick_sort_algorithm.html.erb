<!DOCTYPE html>
<html>
<head>
<title>Data Structures and Algorithms</title>
<%= stylesheet_link_tag 'ds2.scss' %>
 <center><h1>LearnOnline</h1></center>
     <center><h7>-an online study point</h7></center>
      <hr/>
</head>
<body>
<div style="background-color:#FFFFE0;height:1090px;width:300px;float:left;">
<ul>
<class>Data Structures &amp; Algorithms</class>
<li><%= link_to 'Home', dsalgo_index_path%></li>
<li><%= link_to 'Overview', dsalgo_data_structure_overview_path%></li>
<li><%= link_to 'Environment Setup', dsalgo_data_structure_environment_path%></li>
</ul>
<ul>
<class>Algorithms Contents:</class>
<li><%= link_to 'Algorithms Basics', dsalgo_algorithms_basics_path%></li>
<li><%= link_to 'Asymptotic Analysis', dsalgo_asymptotic_analysis_path%></li>
<li><%= link_to 'Greedy Algorithms', dsalgo_greedy_algorithms_path%></li>
<li><%= link_to 'Divide and Conquer', dsalgo_divide_and_conquer_path%></li>
<li><%= link_to 'Dynamic Programming', dsalgo_dynamic_programming_path%></li>
</ul>
<ul>
<class>Data Structures Contents:</class>
<li><%= link_to 'Data Structure Basics', dsalgo_data_structure_basics_path%></li>
<li><%= link_to 'Array Data Structure', dsalgo_array_data_structure_path%></li>
</ul>
<ul>
<class>Linked Lists Contents:</class>
<li><%= link_to 'Linked List Basics', dsalgo_linked_list_basics_path%></li>
<li><%= link_to 'Doubly Linked List', dsalgo_doubly_linked_list_algorithm_path%></li>
<li><%= link_to 'Circular Linked List', dsalgo_circular_linked_list_algorithm_path%></li>
</ul>
<ul>
<class>Stack and Queue Contents:</class>
<li><%= link_to 'Stack', dsalgo_stack_algorithm_path%></li>
<li><%= link_to 'Expression Parsing', dsalgo_expression_parsing_path%></li>
<li><%= link_to 'Queue', dsalgo_queue_path%></li>
</ul>
<ul>
<class>Searching Techniques:</class>
<li><%= link_to 'Linear Search', dsalgo_linear_search_algorithm_path%></li>
<li><%= link_to 'Binary Search', dsalgo_binary_search_algorithm_path%></li>
<li><%= link_to'Interpolation Search', dsalgo_interpolation_search_algorithm_path%></li>
<li><%= link_to 'Hash Table', dsalgo_hash_data_structure_path%></li>
</ul>
<ul>
<class>Sorting Techniques:</class>
<li><%= link_to 'Sorting Algorithms', dsalgo_sorting_algorithms_path%></li>
<li><%= link_to 'Bubble Sort', dsalgo_bubble_sort_algorithm_path%></li>
<li><%= link_to 'Insertion Sort', dsalgo_insertion_sort_algorithm_path%></li>
<li><%= link_to 'Selection Sort', dsalgo_selection_sort_algorithm_path%></li>
<li><%= link_to 'Merge Sort', dsalgo_merge_sort_algorithm_path%></li>
<li><%= link_to 'Shell Sort', dsalgo_shell_sort_algorithm_path%></li>
<li><%= link_to 'Quick Sort', dsalgo_quick_sort_algorithm_path%></li>
</ul>
<ul>
<class>Graphs:</class>
<li><%= link_to 'Graph Data Structure', dsalgo_graph_data_structure_path%></li>
<li><%= link_to 'Depth First Traversal', dsalgo_depth_first_traversal_path%></li>
<li><%= link_to 'Breadth First Traversal', dsalgo_breadth_first_traversal_path%></li>
</ul>
<ul>
<class>Tree:</class>
<li><%= link_to 'Tree Data Structure', dsalgo_tree_data_structure_path%></li>
<li><%= link_to 'Tree Traversal', dsalgo_tree_traversal_path%></li>
<li><%= link_to 'Binary Search Tree', dsalgo_binary_search_tree_path%></li>
<li><%= link_to 'AVL Tree', dsalgo_avl_tree_algorithm_path%></li>
<li><%= link_to 'Spanning Tree', dsalgo_spanning_tree_path%></li>
<li><%= link_to 'Heap', dsalgo_heap_data_structure_path%></li>
</ul>
<ul>
<class>Recursion</class>
<li><%= link_to 'Recursion Basics', dsalgo_recursion_basics_path%></li>
<li><%= link_to 'Tower of Hanoi', dsalgo_tower_of_hanoi_path%></li>
<li><%= link_to 'Fibonacci Series', dsalgo_fibonacci_series_path%></li>
</ul>
</div>
<div style="height:1090px;width:990px;float:right;">
<td style="text-align: right; vertical-align: top">
<div class="front-menu">
<table cellpadding="10">
<tr><td style="text-align: left">
<h4>Data Structure and Algorithms</h4>
<hr />
<p>Quick sort is a highly efficient sorting algorithm and is based on partitioning of array of data into smaller arrays. A large array is partitioned into two arrays one of which holds values smaller than the specified value, say pivot, based on which the partition is made and another array holds values greater than the pivot value.</p> 
<p>Quick sort partitions an array and then calls itself recursively twice to sort the two resulting subarrays. This algorithm is quite efficient for large-sized data sets as its average and worst case complexity are of &Omicron;(n<sup>2</sup>), where <b>n</b> is the number of items.</p>
<h2>Partition in Quick Sort</h2>
<p>Following animated representation explains how to find the pivot value in an array.</p>
<div align="center"><%= image_tag("quick_sort_partition_animation.gif", :alt => "Quick Sort") %></div>
<p>The pivot value divides the list into two parts. And recursively, we find the pivot for each sub-lists until all lists contains only one element.</p>
<h2>Quick Sort Pivot Algorithm</h2>
<p>Based on our understanding of partitioning in quick sort, we will now try to write an algorithm for it, which is as follows.</p>
<pre>
<b>Step 1</b> &minus; Choose the highest index value has pivot
<b>Step 2</b> &minus; Take two variables to point left and right of the list excluding pivot
<b>Step 3</b> &minus; left points to the low index
<b>Step 4</b> &minus; right points to the high
<b>Step 5</b> &minus; while value at left is less than pivot move right
<b>Step 6</b> &minus; while value at right is greater than pivot move left
<b>Step 7</b> &minus; if both step 5 and step 6 does not match swap left and right
<b>Step 8</b> &minus; if left &ge; right, the point where they met is new pivot
</pre>
<h2>Quick Sort Pivot Pseudocode</h2>
<p>The pseudocode for the above algorithm can be derived as &minus;</p>
<pre>
function partitionFunc(left, right, pivot)
   leftPointer = left
   rightPointer = right - 1

   while True do
      while A[&plus;&plus;leftPointer] &lt; pivot do
         //do-nothing            
      end while
		
      while rightPointer &gt; 0 &amp;&amp; A[--rightPointer] &gt; pivot do
         //do-nothing         
      end while
		
      if leftPointer &gt;= rightPointer
         break
      else                
         swap leftPointer,rightPointer
      end if
		
   end while 
	
   swap leftPointer,right
   return leftPointer
	
end function
</pre>
<h2>Quick Sort Algorithm</h2>
<p>Using pivot algorithm recursively, we end up with smaller possible partitions. Each partition is then processed for quick sort. We define recursive algorithm for quicksort as follows &minus;</p>
<pre>
<b>Step 1</b> &minus; Make the right-most index value pivot
<b>Step 2</b> &minus; partition the array using pivot value
<b>Step 3</b> &minus; quicksort left partition recursively
<b>Step 4</b> &minus; quicksort right partition recursively
</pre>
<h2>Quick Sort Pseudocode</h2>
<p>To get more into it, let see the pseudocode for quick sort algorithm &minus;</p>
<pre>
procedure quickSort(left, right)

   if right-left &lt;= 0
      return
   else     
      pivot = A[right]
      partition = partitionFunc(left, right, pivot)
      quickSort(left,partition-1)
      quickSort(partition&plus;1,right)    
   end if		
   
end procedure
</pre>
<hr />
</td>
</tr>
</table>
</div>
</td>
</div>
</body>
</html>
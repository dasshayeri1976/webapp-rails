<!DOCTYPE html>
<html>
<head>
<title>Data Structures and Algorithms</title>
<%= stylesheet_link_tag 'ds2.scss' %>
 <center><h1>LearnOnline</h1></center>
     <center><h7>-an online study point</h7></center>
      <hr/>
</head>
<body>
<div style="background-color:#FFFFE0;height:1090px;width:300px;float:left;">
<ul>
<li><%= link_to 'Home', dsalgo_index_path%></li>
<li><%= link_to 'Overview', dsalgo_data_structure_overview_path%></li>
<li><%= link_to 'Environment Setup', dsalgo_data_structure_environment_path%></li>
</ul>
<ul>
<class>Algorithms Contents:</class>
<li><%= link_to 'Algorithms Basics', dsalgo_algorithms_basics_path%></li>
<li><%= link_to 'Asymptotic Analysis', dsalgo_asymptotic_analysis_path%></li>
<li><%= link_to 'Greedy Algorithms', dsalgo_greedy_algorithms_path%></li>
<li><%= link_to 'Divide and Conquer', dsalgo_divide_and_conquer_path%></li>
<li><%= link_to 'Dynamic Programming', dsalgo_dynamic_programming_path%></li>
</ul>
<ul>
<class>Data Structures Contents:</class>
<li><%= link_to 'Data Structure Basics', dsalgo_data_structure_basics_path%></li>
<li><%= link_to 'Array Data Structure', dsalgo_array_data_structure_path%></li>
</ul>
<ul>
<class>Linked Lists Contents:</class>
<li><%= link_to 'Linked List Basics', dsalgo_linked_list_basics_path%></li>
<li><%= link_to 'Doubly Linked List', dsalgo_doubly_linked_list_algorithm_path%></li>
<li><%= link_to 'Circular Linked List', dsalgo_circular_linked_list_algorithm_path%></li>
</ul>
<ul>
<class>Stack and Queue Contents:</class>
<li><%= link_to 'Stack', dsalgo_stack_algorithm_path%></li>
<li><%= link_to 'Expression Parsing', dsalgo_expression_parsing_path%></li>
<li><%= link_to 'Queue', dsalgo_queue_path%></li>
</ul>
<ul>
<class>Searching Techniques:</class>
<li><%= link_to 'Linear Search', dsalgo_linear_search_algorithm_path%></li>
<li><%= link_to 'Binary Search', dsalgo_binary_search_algorithm_path%></li>
<li><%= link_to'Interpolation Search', dsalgo_interpolation_search_algorithm_path%></li>
<li><%= link_to 'Hash Table', dsalgo_hash_data_structure_path%></li>
</ul>
<ul>
<class>Sorting Techniques:</class>
<li><%= link_to 'Sorting Algorithms', dsalgo_sorting_algorithms_path%></li>
<li><%= link_to 'Bubble Sort', dsalgo_bubble_sort_algorithm_path%></li>
<li><%= link_to 'Insertion Sort', dsalgo_insertion_sort_algorithm_path%></li>
<li><%= link_to 'Selection Sort', dsalgo_selection_sort_algorithm_path%></li>
<li><%= link_to 'Merge Sort', dsalgo_merge_sort_algorithm_path%></li>
<li><%= link_to 'Shell Sort', dsalgo_shell_sort_algorithm_path%></li>
<li><%= link_to 'Quick Sort', dsalgo_quick_sort_algorithm_path%></li>
</ul>
<ul>
<class>Graphs:</class>
<li><%= link_to 'Graph Data Structure', dsalgo_graph_data_structure_path%></li>
<li><%= link_to 'Depth First Traversal', dsalgo_depth_first_traversal_path%></li>
<li><%= link_to 'Breadth First Traversal', dsalgo_breadth_first_traversal_path%></li>
</ul>
<ul>
<class>Tree:</class>
<li><%= link_to 'Tree Data Structure', dsalgo_tree_data_structure_path%></li>
<li><%= link_to 'Tree Traversal', dsalgo_tree_traversal_path%></li>
<li><%= link_to 'Binary Search Tree', dsalgo_binary_search_tree_path%></li>
<li><%= link_to 'AVL Tree', dsalgo_avl_tree_algorithm_path%></li>
<li><%= link_to 'Spanning Tree', dsalgo_spanning_tree_path%></li>
<li><%= link_to 'Heap', dsalgo_heap_data_structure_path%></li>
</ul>
<ul>
<class>Recursion</class>
<li><%= link_to 'Recursion Basics', dsalgo_recursion_basics_path%></li>
<li><%= link_to 'Tower of Hanoi', dsalgo_tower_of_hanoi_path%></li>
<li><%= link_to 'Fibonacci Series', dsalgo_fibonacci_series_path%></li>
</ul>
</div>
<div style="height:1090px;width:990px;float:right;">
<td style="text-align: right; vertical-align: top">
<div class="front-menu">
<table cellpadding="10">
<tr><td style="text-align: left">
<h4>Data Structure and Algorithms</h4>
<p>An algorithm is designed to achieve optimum solution for a given problem. In greedy algorithm approach, decisions are made from the given solution domain. As being greedy, the closest solution that seems to provide an optimum solution is chosen.</p>
<p>Greedy algorithms try to find a localized optimum solution, which may eventually lead to globally optimized solutions. However, generally greedy algorithms do not provide globally optimized solutions.</p>
<h4>Counting Coins</h4>
<p>This problem is to count to a desired value by choosing the least possible coins and the greedy approach forces the algorithm to pick the largest possible coin. If we are provided coins of &#8377; 1, 2, 5 and 10 and we are asked to count &#8377; 18 then the greedy procedure will be &minus;</p>
<ul>
<li><p><b>1</b> &minus; Select one &#8377; 10 coin, the remaining count is 8</p></li>   
<li><p><b>2</b> &minus; Then select one &#8377; 5 coin, the remaining count is 3</p></li>   
<li><p><b>3</b> &minus; Then select one &#8377; 2 coin, the remaining count is 1</p></li>   
<li><p><b>3</b> &minus; And finally, the selection of one &#8377; 1 coins solves the problem</p></li>
</ul>
<p>Though, it seems to be working fine, for this count we need to pick only 4 coins. But if we slightly change the problem then the same approach may not be able to produce the same optimum result.</p>
<p>For the currency system, where we have coins of 1, 7, 10 value, counting coins for value 18 will be absolutely optimum but for count like 15, it may use more coins than necessary. For example, the greedy approach will use 10 &plus; 1 &plus; 1 &plus; 1 &plus; 1 &plus; 1, total 6 coins. Whereas the same problem could be solved by using only 3 coins (7 &plus; 7 &plus; 1)</p>
<p>Hence, we may conclude that the greedy approach picks an immediate optimized solution and may fail where global optimization is a major concern.</p>
<h4>Examples</h4>
<p>Most networking algorithms use the greedy approach. Here is a list of few of them &minus;</p>
<ul>
<li>Travelling Salesman Problem</li>   
<li>Prim's Minimal Spanning Tree Algorithm</li>   
<li>Kruskal's Minimal Spanning Tree Algorithm</li>   
<li>Dijkstra's Minimal Spanning Tree Algorithm</li>   
<li>Graph - Map Coloring</li>   
<li>Graph - Vertex Cover</li>   
<li>Knapsack Problem</li>   
<li>Job Scheduling Problem</li>   
</ul>
<p>There are lots of similar problems that uses the greedy approach to find an optimum solution.</p>
<hr />
</td>
</tr>
</table>
</div>
</td>
</div>
</body>
</html>

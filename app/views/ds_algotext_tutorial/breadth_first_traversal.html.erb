<!DOCTYPE html>
<head>
<title>Data Structures and Algorithms</title>
<%= stylesheet_link_tag 'ds2.scss' %>
 <center><h1>LearnOnline</h1></center>
     <center><h7>-an online study point</h7></center>
      <hr/>
</head>
<body>
<div style="background-color:#FFFFE0;height:1090px;width:300px;float:left;">
<ul>
<class>Data Structures &amp; Algorithms</class>
<li><%= link_to 'Home', dsalgo_index_path%></li>
<li><%= link_to 'Overview', dsalgo_data_structure_overview_path%></li>
<li><%= link_to 'Environment Setup', dsalgo_data_structure_environment_path%></li>
</ul>
<ul>
<class>Algorithms Contents:</class>
<li><%= link_to 'Algorithms Basics', dsalgo_algorithms_basics_path%></li>
<li><%= link_to 'Asymptotic Analysis', dsalgo_asymptotic_analysis_path%></li>
<li><%= link_to 'Greedy Algorithms', dsalgo_greedy_algorithms_path%></li>
<li><%= link_to 'Divide and Conquer', dsalgo_divide_and_conquer_path%></li>
<li><%= link_to 'Dynamic Programming', dsalgo_dynamic_programming_path%></li>
</ul>
<ul>
<class>Data Structures Contents:</class>
<li><%= link_to 'Data Structure Basics', dsalgo_data_structure_basics_path%></li>
<li><%= link_to 'Array Data Structure', dsalgo_array_data_structure_path%></li>
</ul>
<ul>
<class>Linked Lists Contents:</class>
<li><%= link_to 'Linked List Basics', dsalgo_linked_list_basics_path%></li>
<li><%= link_to 'Doubly Linked List', dsalgo_doubly_linked_list_algorithm_path%></li>
<li><%= link_to 'Circular Linked List', dsalgo_circular_linked_list_algorithm_path%></li>
</ul>
<ul>
<class>Stack and Queue Contents:</class>
<li><%= link_to 'Stack', dsalgo_stack_algorithm_path%></li>
<li><%= link_to 'Expression Parsing', dsalgo_expression_parsing_path%></li>
<li><%= link_to 'Queue', dsalgo_queue_path%></li>
</ul>
<ul>
<class>Searching Techniques:</class>
<li><%= link_to 'Linear Search', dsalgo_linear_search_algorithm_path%></li>
<li><%= link_to 'Binary Search', dsalgo_binary_search_algorithm_path%></li>
<li><%= link_to'Interpolation Search', dsalgo_interpolation_search_algorithm_path%></li>
<li><%= link_to 'Hash Table', dsalgo_hash_data_structure_path%></li>
</ul>
<ul>
<class>Sorting Techniques:</class>
<li><%= link_to 'Sorting Algorithms', dsalgo_sorting_algorithms_path%></li>
<li><%= link_to 'Bubble Sort', dsalgo_bubble_sort_algorithm_path%></li>
<li><%= link_to 'Insertion Sort', dsalgo_insertion_sort_algorithm_path%></li>
<li><%= link_to 'Selection Sort', dsalgo_selection_sort_algorithm_path%></li>
<li><%= link_to 'Merge Sort', dsalgo_merge_sort_algorithm_path%></li>
<li><%= link_to 'Shell Sort', dsalgo_shell_sort_algorithm_path%></li>
<li><%= link_to 'Quick Sort', dsalgo_quick_sort_algorithm_path%></li>
</ul>
<ul>
<class>Graphs:</class>
<li><%= link_to 'Graph Data Structure', dsalgo_graph_data_structure_path%></li>
<li><%= link_to 'Depth First Traversal', dsalgo_depth_first_traversal_path%></li>
<li><%= link_to 'Breadth First Traversal', dsalgo_breadth_first_traversal_path%></li>
</ul>
<ul>
<class>Tree:</class>
<li><%= link_to 'Tree Data Structure', dsalgo_tree_data_structure_path%></li>
<li><%= link_to 'Tree Traversal', dsalgo_tree_traversal_path%></li>
<li><%= link_to 'Binary Search Tree', dsalgo_binary_search_tree_path%></li>
<li><%= link_to 'AVL Tree', dsalgo_avl_tree_algorithm_path%></li>
<li><%= link_to 'Spanning Tree', dsalgo_spanning_tree_path%></li>
<li><%= link_to 'Heap', dsalgo_heap_data_structure_path%></li>
</ul>
<ul>
<class>Recursion</class>
<li><%= link_to 'Recursion Basics', dsalgo_recursion_basics_path%></li>
<li><%= link_to 'Tower of Hanoi', dsalgo_tower_of_hanoi_path%></li>
<li><%= link_to 'Fibonacci Series', dsalgo_fibonacci_series_path%></li>
</ul>
</div>
<div style="height:1090px;width:990px;float:right;">
<td style="text-align: right; vertical-align: top">
<div class="front-menu">
<table cellpadding="10">
<tr><td style="text-align: left">
<h4>Data Structure and Algorithms</h4>
<hr />
<p>Breadth First Search (BFS) algorithm traverses a graph in a breadthward motion and uses a queue to remember to get the next vertex to start a search, when a dead end occurs in any iteration.</p>
<p>As in the example given above, BFS algorithm traverses from A to B to E to F first then to C and G lastly to D. It employs the following rules.</p>
<ul>
<li><p><b>Rule 1</b> &minus; Visit the adjacent unvisited vertex. Mark it as visited. Display it. Insert it in a queue.</p></li>
<li><p><b>Rule 2</b> &minus; If no adjacent vertex is found, remove the first vertex from the queue.</p></li>
<li><p><b>Rule 3</b> &minus; Repeat Rule 1 and Rule 2 until the queue is empty.</p></li>
</ul>
<div align="center"><table border="1" cellpadding="5" cellspacing="5" style="text-align:center;" class="table table-bordered">
<tr>
<th style="text-align:center;">Step</th>
<th style="text-align:center;">Traversal</th>
<th style="text-align:center;">Description</th>
</tr>
<tr>
<td style="width:5%; text-align:center; vertical-align:middle;">1.</td>
<td style="width:50%"><%= image_tag("bfs_one.jpg", :alt => "BFS") %></td>
<td>Initialize the queue.</td>
</tr>
<tr>
<td style="width:5%; text-align:center; vertical-align:middle;">2.</td>
<td style="width:50%"><%= image_tag("bfs_two.jpg", :alt => "BFS") %></td>
<td>We start from visiting <b>S</b> (starting node), and mark it as visited.</td>
</tr>
<tr>
<td style="width:5%; text-align:center; vertical-align:middle;">3.</td>
<td style="width:50%"><%= image_tag("bfs_three.jpg", :alt => "BFS") %></td>
<td>We then see an unvisited adjacent node from <b>S</b>. In this example, we have three nodes but alphabetically we choose <b>A</b>, mark it as visited and enqueue it.</td>
</tr>
<tr>
<td style="width:5%; text-align:center; vertical-align:middle;">4.</td>
<td style="width:50%"><%= image_tag("bfs_four.jpg", :alt => "BFS") %></td>
<td>Next, the unvisited adjacent node from <b>S</b> is <b>B</b>. We mark it as visited and enqueue it.</td>
</tr>
<tr>
<td style="width:5%; text-align:center; vertical-align:middle;">5.</td>
<td style="width:50%"><%= image_tag("bfs_five.jpg", :alt => "BFS") %></td>
<td>Next, the unvisited adjacent node from <b>S</b> is <b>C</b>. We mark it as visited and enqueue it.</td>
</tr>
<tr>
<td style="width:5%; text-align:center; vertical-align:middle;">6.</td>
<td style="width:50%"><%= image_tag("bfs_six.jpg", :alt => "BFS") %></td>
<td>Now, <b>S</b> is left with no unvisited adjacent nodes. So, we dequeue and find <b>A</b>.</td>
</tr>
<tr>
<td style="width:5%; text-align:center; vertical-align:middle;">7.</td>
<td style="width:50%"><%= image_tag("bfs_seven.jpg", :alt => "BFS") %></td>
<td>From <b>A</b> we have <b>D</b> as unvisited adjacent node. We mark it as visited and enqueue it.</td>
</tr>
</table><p>At this stage, we are left with no unmarked (unvisited) nodes. But as per the algorithm we keep on dequeuing in order to get all unvisited nodes. When the queue gets emptied, the program is over.</p>
<hr />
</body>
</html>
<!DOCTYPE html>

<html>
<head>
<title>Data Structures and Algorithms</title>
<%= stylesheet_link_tag 'ds2.scss' %>
 <center><h1>LearnOnline</h1></center>
     <center><h7>-an online study point</h7></center>
      <hr/>
</head>
<body>
<div style="background-color:#FFFFE0;height:1090px;width:300px;float:left;">
<ul>
<class>Data Structures &amp; Algorithms</class>
<li><%= link_to 'Home', dsalgo_index_path%></li>
<li><%= link_to 'Overview', dsalgo_data_structure_overview_path%></li>
<li><%= link_to 'Environment Setup', dsalgo_data_structure_environment_path%></li>
</ul>
<ul>
<class>Algorithms Contents:</class>
<li><%= link_to 'Algorithms Basics', dsalgo_algorithms_basics_path%></li>
<li><%= link_to 'Asymptotic Analysis', dsalgo_asymptotic_analysis_path%></li>
<li><%= link_to 'Greedy Algorithms', dsalgo_greedy_algorithms_path%></li>
<li><%= link_to 'Divide and Conquer', dsalgo_divide_and_conquer_path%></li>
<li><%= link_to 'Dynamic Programming', dsalgo_dynamic_programming_path%></li>
</ul>
<ul>
<class>Data Structures Contents:</class>
<li><%= link_to 'Data Structure Basics', dsalgo_data_structure_basics_path%></li>
<li><%= link_to 'Array Data Structure', dsalgo_array_data_structure_path%></li>
</ul>
<ul>
<class>Linked Lists Contents:</class>
<li><%= link_to 'Linked List Basics', dsalgo_linked_list_basics_path%></li>
<li><%= link_to 'Doubly Linked List', dsalgo_doubly_linked_list_algorithm_path%></li>
<li><%= link_to 'Circular Linked List', dsalgo_circular_linked_list_algorithm_path%></li>
</ul>
<ul>
<class>Stack and Queue Contents:</class>
<li><%= link_to 'Stack', dsalgo_stack_algorithm_path%></li>
<li><%= link_to 'Expression Parsing', dsalgo_expression_parsing_path%></li>
<li><%= link_to 'Queue', dsalgo_queue_path%></li>
</ul>
<ul>
<class>Searching Techniques:</class>
<li><%= link_to 'Linear Search', dsalgo_linear_search_algorithm_path%></li>
<li><%= link_to 'Binary Search', dsalgo_binary_search_algorithm_path%></li>
<li><%= link_to'Interpolation Search', dsalgo_interpolation_search_algorithm_path%></li>
<li><%= link_to 'Hash Table', dsalgo_hash_data_structure_path%></li>
</ul>
<ul>
<class>Sorting Techniques:</class>
<li><%= link_to 'Sorting Algorithms', dsalgo_sorting_algorithms_path%></li>
<li><%= link_to 'Bubble Sort', dsalgo_bubble_sort_algorithm_path%></li>
<li><%= link_to 'Insertion Sort', dsalgo_insertion_sort_algorithm_path%></li>
<li><%= link_to 'Selection Sort', dsalgo_selection_sort_algorithm_path%></li>
<li><%= link_to 'Merge Sort', dsalgo_merge_sort_algorithm_path%></li>
<li><%= link_to 'Shell Sort', dsalgo_shell_sort_algorithm_path%></li>
<li><%= link_to 'Quick Sort', dsalgo_quick_sort_algorithm_path%></li>
</ul>
<ul>
<class>Graphs:</class>
<li><%= link_to 'Graph Data Structure', dsalgo_graph_data_structure_path%></li>
<li><%= link_to 'Depth First Traversal', dsalgo_depth_first_traversal_path%></li>
<li><%= link_to 'Breadth First Traversal', dsalgo_breadth_first_traversal_path%></li>
</ul>
<ul>
<class>Tree:</class>
<li><%= link_to 'Tree Data Structure', dsalgo_tree_data_structure_path%></li>
<li><%= link_to 'Tree Traversal', dsalgo_tree_traversal_path%></li>
<li><%= link_to 'Binary Search Tree', dsalgo_binary_search_tree_path%></li>
<li><%= link_to 'AVL Tree', dsalgo_avl_tree_algorithm_path%></li>
<li><%= link_to 'Spanning Tree', dsalgo_spanning_tree_path%></li>
<li><%= link_to 'Heap', dsalgo_heap_data_structure_path%></li>
</ul>
<ul>
<class>Recursion</class>
<li><%= link_to 'Recursion Basics', dsalgo_recursion_basics_path%></li>
<li><%= link_to 'Tower of Hanoi', dsalgo_tower_of_hanoi_path%></li>
<li><%= link_to 'Fibonacci Series', dsalgo_fibonacci_series_path%></li>
</ul>
</div>
<div style="height:1090px;width:990px;float:right;">
<td style="text-align: right; vertical-align: top">
<div class="front-menu">
<table cellpadding="10">
<tr><td style="text-align: left">
<h4>Data Structure and Algorithms</h4>
<hr />
<p>Merge sort is a sorting technique based on divide and conquer technique. With worst-case time complexity being &Omicron;(n log n), it is one of the most respected algorithms.</p>
<p>Merge sort first divides the array into equal halves and then combines them in a sorted manner.</p>
<h4>How Merge Sort Works?</h4>
<p>To understand merge sort, we take an unsorted array as the following &minus;</p>
<div align="center"><%= image_tag("unsorted_array(1).jpg", :alt => "Merge Sort") %></div>
<p>We know that merge sort first divides the whole array iteratively into equal halves unless the atomic values are achieved. We see here that an array of 8 items is divided into two arrays of size 4.</p>
<div align="center"><%= image_tag("merge_sort_divide_1.jpg", :alt => "Merge Sort") %></div>
<p>This does not change the sequence of appearance of items in the original. Now we divide these two arrays into halves.</p>
<div align="center"><%= image_tag("merge_sort_divide_2.jpg", :alt => "Merge Sort") %></div>
<p>We further divide these arrays and we achieve atomic value which can no more be divided.</p>
<div align="center"><%= image_tag("merge_sort_divide_3.jpg", :alt => "Merge Sort") %></div>
<p>Now, we combine them in exactly the same manner as they were broken down. Please note the color codes given to these lists.</p>
<p>We first compare the element for each list and then combine them into another list in a sorted manner. We see that 14 and 33 are in sorted positions. We compare 27 and 10 and in the target list of 2 values we put 10 first, followed by 27. We change the order of 19 and 35 whereas 42 and 44 are placed sequentially.</p>
<div align="center"><%= image_tag("merge_sort_combine_1.jpg", :alt => "Merge Sort") %></div>
<p>In the next iteration of the combining phase, we compare lists of two data values, and merge them into a list of found data values placing all in a sorted order.</p>
<div align="center"><%= image_tag("merge_sort_combine_2.jpg", :alt => "Merge Sort") %></div>
<p>After the final merging, the list should look like this &minus;</p>
<div align="center"><%= image_tag("merge_sort.jpg", :alt => "Merge Sort") %></div>
<p>Now we should learn some programming aspects of merge sorting.</p>
<h4>Algorithm</h4>
<p>Merge sort keeps on dividing the list into equal halves until it can no more be divided. By definition, if it is only one element in the list, it is sorted. Then, merge sort combines the smaller sorted lists keeping the new list sorted too.</p>
<pre>
<b>Step 1</b> &minus; if it is only one element in the list it is already sorted, return.
<b>Step 2</b> &minus; divide the list recursively into two halves until it can no more be divided.
<b>Step 3</b> &minus; merge the smaller lists into new list in sorted order.
</pre>
<h4>Pseudocode</h4>
<p>We shall now see the pseudocodes for merge sort functions. As our algorithms point out two main functions âˆ’ divide &amp; merge.</p>
<p>Merge sort works with recursion and we shall see our implementation in the same way.</p>
<pre>
procedure mergesort( var a as array )
   if ( n == 1 ) return a

   var l1 as array = a[0] ... a[n/2]
   var l2 as array = a[n/2+1] ... a[n]

   l1 = mergesort( l1 )
   l2 = mergesort( l2 )

   return merge( l1, l2 )
end procedure

procedure merge( var a as array, var b as array )

   var c as array

   while ( a and b have elements )
      if ( a[0] &gt; b[0] )
         add b[0] to the end of c
         remove b[0] from b
      else
         add a[0] to the end of c
         remove a[0] from a
      end if
   end while
   
   while ( a has elements )
      add a[0] to the end of c
      remove a[0] from a
   end while
   
   while ( b has elements )
      add b[0] to the end of c
      remove b[0] from b
   end while
   
   return c
	
end procedure
</pre>
<hr />
</td>
</tr>
</table>
</div>
</td>
</div>
</body>
</html>